// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: meta.proto

package json_bench

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	github_com_golang_protobuf_proto "github.com/golang/protobuf/proto"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type PColumnInfo struct {
	ID                    int64    `protobuf:"varint,1,opt,name=ID" json:"ID"`
	Name                  string   `protobuf:"bytes,2,opt,name=Name" json:"Name"`
	Offset                int32    `protobuf:"varint,3,opt,name=Offset" json:"Offset"`
	OriginDefaultValue    int64    `protobuf:"varint,4,opt,name=OriginDefaultValue" json:"OriginDefaultValue"`
	OriginDefaultValueBit []byte   `protobuf:"bytes,5,opt,name=OriginDefaultValueBit" json:"OriginDefaultValueBit"`
	DefaultValue          int64    `protobuf:"varint,6,opt,name=DefaultValue" json:"DefaultValue"`
	DefaultValueBit       []byte   `protobuf:"bytes,7,opt,name=DefaultValueBit" json:"DefaultValueBit"`
	DefaultIsExpr         bool     `protobuf:"varint,8,opt,name=DefaultIsExpr" json:"DefaultIsExpr"`
	GeneratedExprString   string   `protobuf:"bytes,9,opt,name=GeneratedExprString" json:"GeneratedExprString"`
	GeneratedStored       bool     `protobuf:"varint,10,opt,name=GeneratedStored" json:"GeneratedStored"`
	Dependences           int64    `protobuf:"varint,11,opt,name=Dependences" json:"Dependences"`
	Comment               string   `protobuf:"bytes,12,opt,name=Comment" json:"Comment"`
	Hidden                bool     `protobuf:"varint,13,opt,name=Hidden" json:"Hidden"`
	Version               int64    `protobuf:"varint,14,opt,name=Version" json:"Version"`
	XXX_NoUnkeyedLiteral  struct{} `json:"-"`
	XXX_unrecognized      []byte   `json:"-"`
	XXX_sizecache         int32    `json:"-"`
}

func (m *PColumnInfo) Reset()         { *m = PColumnInfo{} }
func (m *PColumnInfo) String() string { return proto.CompactTextString(m) }
func (*PColumnInfo) ProtoMessage()    {}
func (*PColumnInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{0}
}
func (m *PColumnInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PColumnInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PColumnInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PColumnInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PColumnInfo.Merge(m, src)
}
func (m *PColumnInfo) XXX_Size() int {
	return m.Size()
}
func (m *PColumnInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PColumnInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PColumnInfo proto.InternalMessageInfo

func (m *PColumnInfo) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *PColumnInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PColumnInfo) GetOffset() int32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *PColumnInfo) GetOriginDefaultValue() int64 {
	if m != nil {
		return m.OriginDefaultValue
	}
	return 0
}

func (m *PColumnInfo) GetOriginDefaultValueBit() []byte {
	if m != nil {
		return m.OriginDefaultValueBit
	}
	return nil
}

func (m *PColumnInfo) GetDefaultValue() int64 {
	if m != nil {
		return m.DefaultValue
	}
	return 0
}

func (m *PColumnInfo) GetDefaultValueBit() []byte {
	if m != nil {
		return m.DefaultValueBit
	}
	return nil
}

func (m *PColumnInfo) GetDefaultIsExpr() bool {
	if m != nil {
		return m.DefaultIsExpr
	}
	return false
}

func (m *PColumnInfo) GetGeneratedExprString() string {
	if m != nil {
		return m.GeneratedExprString
	}
	return ""
}

func (m *PColumnInfo) GetGeneratedStored() bool {
	if m != nil {
		return m.GeneratedStored
	}
	return false
}

func (m *PColumnInfo) GetDependences() int64 {
	if m != nil {
		return m.Dependences
	}
	return 0
}

func (m *PColumnInfo) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *PColumnInfo) GetHidden() bool {
	if m != nil {
		return m.Hidden
	}
	return false
}

func (m *PColumnInfo) GetVersion() int64 {
	if m != nil {
		return m.Version
	}
	return 0
}

type PIndexInfo struct {
	ID                   int64    `protobuf:"varint,1,opt,name=ID" json:"ID"`
	Name                 string   `protobuf:"bytes,2,opt,name=Name" json:"Name"`
	Table                string   `protobuf:"bytes,3,opt,name=Table" json:"Table"`
	Columns              []string `protobuf:"bytes,4,rep,name=Columns" json:"Columns,omitempty"`
	Comment              string   `protobuf:"bytes,5,opt,name=Comment" json:"Comment"`
	Unique               bool     `protobuf:"varint,6,opt,name=Unique" json:"Unique"`
	Primary              bool     `protobuf:"varint,7,opt,name=Primary" json:"Primary"`
	Invisible            bool     `protobuf:"varint,8,opt,name=Invisible" json:"Invisible"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PIndexInfo) Reset()         { *m = PIndexInfo{} }
func (m *PIndexInfo) String() string { return proto.CompactTextString(m) }
func (*PIndexInfo) ProtoMessage()    {}
func (*PIndexInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{1}
}
func (m *PIndexInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PIndexInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PIndexInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PIndexInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PIndexInfo.Merge(m, src)
}
func (m *PIndexInfo) XXX_Size() int {
	return m.Size()
}
func (m *PIndexInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PIndexInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PIndexInfo proto.InternalMessageInfo

func (m *PIndexInfo) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *PIndexInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PIndexInfo) GetTable() string {
	if m != nil {
		return m.Table
	}
	return ""
}

func (m *PIndexInfo) GetColumns() []string {
	if m != nil {
		return m.Columns
	}
	return nil
}

func (m *PIndexInfo) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *PIndexInfo) GetUnique() bool {
	if m != nil {
		return m.Unique
	}
	return false
}

func (m *PIndexInfo) GetPrimary() bool {
	if m != nil {
		return m.Primary
	}
	return false
}

func (m *PIndexInfo) GetInvisible() bool {
	if m != nil {
		return m.Invisible
	}
	return false
}

type PTableInfo struct {
	ID                   int64          `protobuf:"varint,1,req,name=ID" json:"ID"`
	Name                 string         `protobuf:"bytes,2,opt,name=Name" json:"Name"`
	Charset              string         `protobuf:"bytes,3,opt,name=Charset" json:"Charset"`
	Collate              string         `protobuf:"bytes,4,opt,name=Collate" json:"Collate"`
	Columns              []*PColumnInfo `protobuf:"bytes,5,rep,name=Columns" json:"Columns,omitempty"`
	Indices              []*PIndexInfo  `protobuf:"bytes,6,rep,name=Indices" json:"Indices,omitempty"`
	PKIsHandle           bool           `protobuf:"varint,7,opt,name=PKIsHandle" json:"PKIsHandle"`
	IsCommonHandle       bool           `protobuf:"varint,8,opt,name=IsCommonHandle" json:"IsCommonHandle"`
	Comment              string         `protobuf:"bytes,9,opt,name=Comment" json:"Comment"`
	AutoIncID            int64          `protobuf:"varint,10,opt,name=AutoIncID" json:"AutoIncID"`
	AutoIdCache          int64          `protobuf:"varint,11,opt,name=AutoIdCache" json:"AutoIdCache"`
	AutoRandID           int64          `protobuf:"varint,12,opt,name=AutoRandID" json:"AutoRandID"`
	MaxColumnID          int64          `protobuf:"varint,13,opt,name=MaxColumnID" json:"MaxColumnID"`
	MaxIndexID           int64          `protobuf:"varint,14,opt,name=MaxIndexID" json:"MaxIndexID"`
	MaxConstraintID      int64          `protobuf:"varint,15,opt,name=MaxConstraintID" json:"MaxConstraintID"`
	UpdateTS             int64          `protobuf:"varint,16,opt,name=UpdateTS" json:"UpdateTS"`
	OldSchemaID          int64          `protobuf:"varint,17,opt,name=OldSchemaID" json:"OldSchemaID"`
	ShardRowIDBits       int64          `protobuf:"varint,18,opt,name=ShardRowIDBits" json:"ShardRowIDBits"`
	MaxShardRowIDBits    int64          `protobuf:"varint,19,opt,name=MaxShardRowIDBits" json:"MaxShardRowIDBits"`
	AutoRandomBits       int64          `protobuf:"varint,20,opt,name=AutoRandomBits" json:"AutoRandomBits"`
	PreSplitRegions      int64          `protobuf:"varint,21,opt,name=PreSplitRegions" json:"PreSplitRegions"`
	Compression          string         `protobuf:"bytes,22,opt,name=Compression" json:"Compression"`
	Version              int64          `protobuf:"varint,23,opt,name=Version" json:"Version"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *PTableInfo) Reset()         { *m = PTableInfo{} }
func (m *PTableInfo) String() string { return proto.CompactTextString(m) }
func (*PTableInfo) ProtoMessage()    {}
func (*PTableInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{2}
}
func (m *PTableInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PTableInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PTableInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PTableInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PTableInfo.Merge(m, src)
}
func (m *PTableInfo) XXX_Size() int {
	return m.Size()
}
func (m *PTableInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PTableInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PTableInfo proto.InternalMessageInfo

func (m *PTableInfo) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *PTableInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PTableInfo) GetCharset() string {
	if m != nil {
		return m.Charset
	}
	return ""
}

func (m *PTableInfo) GetCollate() string {
	if m != nil {
		return m.Collate
	}
	return ""
}

func (m *PTableInfo) GetColumns() []*PColumnInfo {
	if m != nil {
		return m.Columns
	}
	return nil
}

func (m *PTableInfo) GetIndices() []*PIndexInfo {
	if m != nil {
		return m.Indices
	}
	return nil
}

func (m *PTableInfo) GetPKIsHandle() bool {
	if m != nil {
		return m.PKIsHandle
	}
	return false
}

func (m *PTableInfo) GetIsCommonHandle() bool {
	if m != nil {
		return m.IsCommonHandle
	}
	return false
}

func (m *PTableInfo) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *PTableInfo) GetAutoIncID() int64 {
	if m != nil {
		return m.AutoIncID
	}
	return 0
}

func (m *PTableInfo) GetAutoIdCache() int64 {
	if m != nil {
		return m.AutoIdCache
	}
	return 0
}

func (m *PTableInfo) GetAutoRandID() int64 {
	if m != nil {
		return m.AutoRandID
	}
	return 0
}

func (m *PTableInfo) GetMaxColumnID() int64 {
	if m != nil {
		return m.MaxColumnID
	}
	return 0
}

func (m *PTableInfo) GetMaxIndexID() int64 {
	if m != nil {
		return m.MaxIndexID
	}
	return 0
}

func (m *PTableInfo) GetMaxConstraintID() int64 {
	if m != nil {
		return m.MaxConstraintID
	}
	return 0
}

func (m *PTableInfo) GetUpdateTS() int64 {
	if m != nil {
		return m.UpdateTS
	}
	return 0
}

func (m *PTableInfo) GetOldSchemaID() int64 {
	if m != nil {
		return m.OldSchemaID
	}
	return 0
}

func (m *PTableInfo) GetShardRowIDBits() int64 {
	if m != nil {
		return m.ShardRowIDBits
	}
	return 0
}

func (m *PTableInfo) GetMaxShardRowIDBits() int64 {
	if m != nil {
		return m.MaxShardRowIDBits
	}
	return 0
}

func (m *PTableInfo) GetAutoRandomBits() int64 {
	if m != nil {
		return m.AutoRandomBits
	}
	return 0
}

func (m *PTableInfo) GetPreSplitRegions() int64 {
	if m != nil {
		return m.PreSplitRegions
	}
	return 0
}

func (m *PTableInfo) GetCompression() string {
	if m != nil {
		return m.Compression
	}
	return ""
}

func (m *PTableInfo) GetVersion() int64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func init() {
	proto.RegisterType((*PColumnInfo)(nil), "json_bench.PColumnInfo")
	proto.RegisterType((*PIndexInfo)(nil), "json_bench.PIndexInfo")
	proto.RegisterType((*PTableInfo)(nil), "json_bench.PTableInfo")
}

func init() { proto.RegisterFile("meta.proto", fileDescriptor_3b5ea8fe65782bcc) }

var fileDescriptor_3b5ea8fe65782bcc = []byte{
	// 764 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x54, 0xcb, 0x6e, 0xdb, 0x46,
	0x14, 0x35, 0xf5, 0xb0, 0xac, 0x91, 0x1f, 0xf5, 0xf8, 0x35, 0x70, 0x0b, 0x95, 0x10, 0x8a, 0x42,
	0x28, 0x5a, 0xb9, 0x35, 0x8a, 0x2e, 0xba, 0x8b, 0xc4, 0x20, 0x26, 0x02, 0xc7, 0x82, 0x64, 0x7b,
	0x1b, 0x8c, 0xc8, 0x91, 0x34, 0x01, 0x39, 0xc3, 0x90, 0xa3, 0x44, 0xf9, 0x92, 0xe4, 0x77, 0xb2,
	0xf3, 0x32, 0x5f, 0x10, 0x04, 0xce, 0x5f, 0x64, 0x15, 0xcc, 0x88, 0x94, 0x2e, 0x69, 0x05, 0x08,
	0xb2, 0x23, 0xcf, 0xb9, 0xcf, 0x73, 0xef, 0x1d, 0x84, 0x42, 0xa6, 0x68, 0x27, 0x8a, 0xa5, 0x92,
	0x18, 0xbd, 0x48, 0xa4, 0x78, 0x3e, 0x62, 0xc2, 0x9b, 0x9e, 0xfe, 0x35, 0xe1, 0x6a, 0x3a, 0x1b,
	0x75, 0x3c, 0x19, 0x9e, 0x4d, 0xe4, 0x44, 0x9e, 0x19, 0x93, 0xd1, 0x6c, 0x6c, 0xfe, 0xcc, 0x8f,
	0xf9, 0x5a, 0xb8, 0xb6, 0xde, 0x57, 0x50, 0xa3, 0xdf, 0x93, 0xc1, 0x2c, 0x14, 0xae, 0x18, 0x4b,
	0x7c, 0x88, 0x4a, 0xae, 0x43, 0x2c, 0xdb, 0x6a, 0x97, 0xbb, 0x95, 0xbb, 0x8f, 0xbf, 0x6e, 0x0c,
	0x4a, 0xae, 0x83, 0x09, 0xaa, 0x3c, 0xa3, 0x21, 0x23, 0x25, 0xdb, 0x6a, 0xd7, 0x53, 0xdc, 0x20,
	0xf8, 0x17, 0xb4, 0x79, 0x35, 0x1e, 0x27, 0x4c, 0x91, 0xb2, 0x6d, 0xb5, 0xab, 0x29, 0x97, 0x62,
	0xf8, 0x5f, 0x84, 0xaf, 0x62, 0x3e, 0xe1, 0xc2, 0x61, 0x63, 0x3a, 0x0b, 0xd4, 0x2d, 0x0d, 0x66,
	0x8c, 0x54, 0x40, 0xf4, 0x35, 0x3c, 0xfe, 0x1f, 0x1d, 0x3d, 0x44, 0xbb, 0x5c, 0x91, 0xaa, 0x6d,
	0xb5, 0xb7, 0x53, 0xc7, 0xf5, 0x26, 0xb8, 0x8d, 0xb6, 0x73, 0xb9, 0x36, 0x41, 0xae, 0x1c, 0x83,
	0x3b, 0x68, 0xaf, 0x18, 0xbf, 0x06, 0xe2, 0x17, 0x49, 0xfc, 0x07, 0xda, 0x49, 0x21, 0x37, 0x79,
	0x3c, 0x8f, 0x62, 0xb2, 0x65, 0x5b, 0xed, 0xad, 0xd4, 0x3a, 0x4f, 0xe1, 0xff, 0xd0, 0xc1, 0x13,
	0x26, 0x58, 0x4c, 0x15, 0xf3, 0x35, 0x30, 0x54, 0x31, 0x17, 0x13, 0x52, 0x07, 0xf2, 0xad, 0x33,
	0xd0, 0x35, 0x2d, 0xe1, 0xa1, 0x92, 0x31, 0xf3, 0x09, 0x02, 0x59, 0x8a, 0x24, 0xfe, 0x1d, 0x35,
	0x1c, 0x16, 0x31, 0xe1, 0x33, 0xe1, 0xb1, 0x84, 0x34, 0x40, 0xb3, 0x90, 0xc0, 0x4d, 0x54, 0xeb,
	0xc9, 0x30, 0x64, 0x42, 0x91, 0x6d, 0x50, 0x43, 0x06, 0xea, 0x29, 0x5e, 0x70, 0xdf, 0x67, 0x82,
	0xec, 0x80, 0x74, 0x29, 0xa6, 0xbd, 0x6f, 0x59, 0x9c, 0x70, 0x29, 0xc8, 0x2e, 0xc8, 0x90, 0x81,
	0xad, 0x2f, 0x16, 0x42, 0x7d, 0x57, 0xf8, 0x6c, 0xfe, 0x43, 0x2b, 0x74, 0x8a, 0xaa, 0xd7, 0x74,
	0x14, 0x30, 0xb3, 0x41, 0x19, 0xb5, 0x80, 0x16, 0x85, 0xeb, 0xe5, 0x4c, 0x48, 0xc5, 0x2e, 0xc3,
	0xc2, 0x0d, 0x08, 0x1b, 0xab, 0x7e, 0xa3, 0xb1, 0x1b, 0xc1, 0x5f, 0xa6, 0x8b, 0xb0, 0x6c, 0x6c,
	0x81, 0x69, 0xef, 0x7e, 0xcc, 0x43, 0x1a, 0xbf, 0x31, 0xa3, 0xcf, 0xe8, 0x0c, 0xc4, 0x2d, 0x54,
	0x77, 0xc5, 0x2b, 0x9e, 0x70, 0x5d, 0x1d, 0x1c, 0xf7, 0x0a, 0x6e, 0xbd, 0xad, 0x21, 0xd4, 0x37,
	0xc5, 0xe6, 0x9a, 0x2f, 0x7d, 0x67, 0xf3, 0xba, 0x81, 0x29, 0x8d, 0xb3, 0x03, 0x5a, 0x35, 0xb0,
	0x00, 0x53, 0x01, 0x02, 0xaa, 0x16, 0x67, 0x03, 0x05, 0xd0, 0x20, 0xfe, 0x67, 0x25, 0x50, 0xd5,
	0x2e, 0xb7, 0x1b, 0xe7, 0x27, 0x9d, 0xd5, 0x63, 0xd0, 0x01, 0x97, 0xbd, 0xd2, 0xec, 0x6f, 0x54,
	0x73, 0x85, 0xcf, 0xf5, 0xc2, 0x6c, 0x1a, 0x97, 0xe3, 0x9c, 0xcb, 0x72, 0x90, 0x83, 0xcc, 0x0c,
	0xff, 0x86, 0x50, 0xff, 0xa9, 0x9b, 0x5c, 0x50, 0xe1, 0x07, 0x2c, 0x27, 0x15, 0xc0, 0xf1, 0x9f,
	0x68, 0xd7, 0x4d, 0xb4, 0xf0, 0x52, 0xa4, 0x96, 0x50, 0xb2, 0x02, 0x07, 0x27, 0x57, 0x5f, 0x37,
	0xb9, 0x16, 0xaa, 0x3f, 0x9a, 0x29, 0xe9, 0x0a, 0xcf, 0x75, 0xcc, 0x11, 0x64, 0x7a, 0xae, 0x60,
	0xbd, 0xfe, 0xe6, 0xc7, 0xef, 0x51, 0x6f, 0xca, 0xf2, 0xeb, 0x0f, 0x08, 0x5d, 0xbf, 0xfe, 0x1d,
	0x50, 0xe1, 0xbb, 0x8e, 0xb9, 0x80, 0xcc, 0x0c, 0xe0, 0x3a, 0xda, 0x25, 0x9d, 0xa7, 0x8a, 0x39,
	0xe6, 0x12, 0x96, 0xd1, 0x00, 0xa1, 0xa3, 0x5d, 0xd2, 0xf9, 0x42, 0x26, 0x27, 0x77, 0x11, 0x00,
	0xd7, 0xa7, 0x6c, 0x9c, 0x44, 0xa2, 0x62, 0xca, 0x85, 0x72, 0x1d, 0xb2, 0x07, 0x4c, 0x8b, 0x24,
	0xb6, 0xd1, 0xd6, 0x4d, 0xe4, 0x53, 0xc5, 0xae, 0x87, 0xe4, 0x27, 0x60, 0xb8, 0x44, 0x75, 0x7d,
	0x57, 0x81, 0x3f, 0xf4, 0xa6, 0x2c, 0xa4, 0xae, 0x43, 0xf6, 0x61, 0x7d, 0x80, 0xd0, 0x73, 0x18,
	0x4e, 0x69, 0xec, 0x0f, 0xe4, 0x6b, 0xd7, 0xe9, 0x72, 0x95, 0x10, 0x0c, 0x4c, 0x0b, 0x1c, 0x3e,
	0x47, 0xfb, 0x97, 0x74, 0x5e, 0x70, 0x38, 0x00, 0x0e, 0x0f, 0x69, 0x9d, 0x21, 0xd3, 0x4d, 0x86,
	0xc6, 0xe1, 0x10, 0x66, 0xc8, 0x73, 0x5a, 0x89, 0x7e, 0xcc, 0x86, 0x51, 0xc0, 0xd5, 0x80, 0x4d,
	0xb8, 0x14, 0x09, 0x39, 0x82, 0x4a, 0x14, 0x48, 0xdd, 0x67, 0x4f, 0x86, 0x51, 0xcc, 0x12, 0xf3,
	0xe4, 0x1c, 0x83, 0xed, 0x80, 0x04, 0x7c, 0x96, 0x4e, 0xd6, 0x3c, 0x4b, 0xdd, 0xb3, 0xbb, 0xfb,
	0xa6, 0xf5, 0xe1, 0xbe, 0x69, 0x7d, 0xba, 0x6f, 0x5a, 0xef, 0x3e, 0x37, 0x37, 0xd0, 0xcf, 0x9e,
	0x0c, 0x3b, 0x11, 0x17, 0x13, 0x8f, 0x46, 0x1d, 0xc5, 0xfd, 0x11, 0x58, 0xfc, 0xbe, 0xf5, 0x35,
	0x00, 0x00, 0xff, 0xff, 0x7b, 0x04, 0xa1, 0x91, 0x53, 0x07, 0x00, 0x00,
}

func (m *PColumnInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PColumnInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PColumnInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	i = encodeVarintMeta(dAtA, i, uint64(m.Version))
	i--
	dAtA[i] = 0x70
	i--
	if m.Hidden {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x68
	i -= len(m.Comment)
	copy(dAtA[i:], m.Comment)
	i = encodeVarintMeta(dAtA, i, uint64(len(m.Comment)))
	i--
	dAtA[i] = 0x62
	i = encodeVarintMeta(dAtA, i, uint64(m.Dependences))
	i--
	dAtA[i] = 0x58
	i--
	if m.GeneratedStored {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x50
	i -= len(m.GeneratedExprString)
	copy(dAtA[i:], m.GeneratedExprString)
	i = encodeVarintMeta(dAtA, i, uint64(len(m.GeneratedExprString)))
	i--
	dAtA[i] = 0x4a
	i--
	if m.DefaultIsExpr {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x40
	if m.DefaultValueBit != nil {
		i -= len(m.DefaultValueBit)
		copy(dAtA[i:], m.DefaultValueBit)
		i = encodeVarintMeta(dAtA, i, uint64(len(m.DefaultValueBit)))
		i--
		dAtA[i] = 0x3a
	}
	i = encodeVarintMeta(dAtA, i, uint64(m.DefaultValue))
	i--
	dAtA[i] = 0x30
	if m.OriginDefaultValueBit != nil {
		i -= len(m.OriginDefaultValueBit)
		copy(dAtA[i:], m.OriginDefaultValueBit)
		i = encodeVarintMeta(dAtA, i, uint64(len(m.OriginDefaultValueBit)))
		i--
		dAtA[i] = 0x2a
	}
	i = encodeVarintMeta(dAtA, i, uint64(m.OriginDefaultValue))
	i--
	dAtA[i] = 0x20
	i = encodeVarintMeta(dAtA, i, uint64(m.Offset))
	i--
	dAtA[i] = 0x18
	i -= len(m.Name)
	copy(dAtA[i:], m.Name)
	i = encodeVarintMeta(dAtA, i, uint64(len(m.Name)))
	i--
	dAtA[i] = 0x12
	i = encodeVarintMeta(dAtA, i, uint64(m.ID))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *PIndexInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PIndexInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PIndexInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	i--
	if m.Invisible {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x40
	i--
	if m.Primary {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x38
	i--
	if m.Unique {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x30
	i -= len(m.Comment)
	copy(dAtA[i:], m.Comment)
	i = encodeVarintMeta(dAtA, i, uint64(len(m.Comment)))
	i--
	dAtA[i] = 0x2a
	if len(m.Columns) > 0 {
		for iNdEx := len(m.Columns) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Columns[iNdEx])
			copy(dAtA[i:], m.Columns[iNdEx])
			i = encodeVarintMeta(dAtA, i, uint64(len(m.Columns[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	i -= len(m.Table)
	copy(dAtA[i:], m.Table)
	i = encodeVarintMeta(dAtA, i, uint64(len(m.Table)))
	i--
	dAtA[i] = 0x1a
	i -= len(m.Name)
	copy(dAtA[i:], m.Name)
	i = encodeVarintMeta(dAtA, i, uint64(len(m.Name)))
	i--
	dAtA[i] = 0x12
	i = encodeVarintMeta(dAtA, i, uint64(m.ID))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *PTableInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PTableInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PTableInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	i = encodeVarintMeta(dAtA, i, uint64(m.Version))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xb8
	i -= len(m.Compression)
	copy(dAtA[i:], m.Compression)
	i = encodeVarintMeta(dAtA, i, uint64(len(m.Compression)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xb2
	i = encodeVarintMeta(dAtA, i, uint64(m.PreSplitRegions))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xa8
	i = encodeVarintMeta(dAtA, i, uint64(m.AutoRandomBits))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xa0
	i = encodeVarintMeta(dAtA, i, uint64(m.MaxShardRowIDBits))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x98
	i = encodeVarintMeta(dAtA, i, uint64(m.ShardRowIDBits))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x90
	i = encodeVarintMeta(dAtA, i, uint64(m.OldSchemaID))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x88
	i = encodeVarintMeta(dAtA, i, uint64(m.UpdateTS))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x80
	i = encodeVarintMeta(dAtA, i, uint64(m.MaxConstraintID))
	i--
	dAtA[i] = 0x78
	i = encodeVarintMeta(dAtA, i, uint64(m.MaxIndexID))
	i--
	dAtA[i] = 0x70
	i = encodeVarintMeta(dAtA, i, uint64(m.MaxColumnID))
	i--
	dAtA[i] = 0x68
	i = encodeVarintMeta(dAtA, i, uint64(m.AutoRandID))
	i--
	dAtA[i] = 0x60
	i = encodeVarintMeta(dAtA, i, uint64(m.AutoIdCache))
	i--
	dAtA[i] = 0x58
	i = encodeVarintMeta(dAtA, i, uint64(m.AutoIncID))
	i--
	dAtA[i] = 0x50
	i -= len(m.Comment)
	copy(dAtA[i:], m.Comment)
	i = encodeVarintMeta(dAtA, i, uint64(len(m.Comment)))
	i--
	dAtA[i] = 0x4a
	i--
	if m.IsCommonHandle {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x40
	i--
	if m.PKIsHandle {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x38
	if len(m.Indices) > 0 {
		for iNdEx := len(m.Indices) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Indices[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMeta(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Columns) > 0 {
		for iNdEx := len(m.Columns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Columns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMeta(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	i -= len(m.Collate)
	copy(dAtA[i:], m.Collate)
	i = encodeVarintMeta(dAtA, i, uint64(len(m.Collate)))
	i--
	dAtA[i] = 0x22
	i -= len(m.Charset)
	copy(dAtA[i:], m.Charset)
	i = encodeVarintMeta(dAtA, i, uint64(len(m.Charset)))
	i--
	dAtA[i] = 0x1a
	i -= len(m.Name)
	copy(dAtA[i:], m.Name)
	i = encodeVarintMeta(dAtA, i, uint64(len(m.Name)))
	i--
	dAtA[i] = 0x12
	i = encodeVarintMeta(dAtA, i, uint64(m.ID))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func encodeVarintMeta(dAtA []byte, offset int, v uint64) int {
	offset -= sovMeta(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *PColumnInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMeta(uint64(m.ID))
	l = len(m.Name)
	n += 1 + l + sovMeta(uint64(l))
	n += 1 + sovMeta(uint64(m.Offset))
	n += 1 + sovMeta(uint64(m.OriginDefaultValue))
	if m.OriginDefaultValueBit != nil {
		l = len(m.OriginDefaultValueBit)
		n += 1 + l + sovMeta(uint64(l))
	}
	n += 1 + sovMeta(uint64(m.DefaultValue))
	if m.DefaultValueBit != nil {
		l = len(m.DefaultValueBit)
		n += 1 + l + sovMeta(uint64(l))
	}
	n += 2
	l = len(m.GeneratedExprString)
	n += 1 + l + sovMeta(uint64(l))
	n += 2
	n += 1 + sovMeta(uint64(m.Dependences))
	l = len(m.Comment)
	n += 1 + l + sovMeta(uint64(l))
	n += 2
	n += 1 + sovMeta(uint64(m.Version))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PIndexInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMeta(uint64(m.ID))
	l = len(m.Name)
	n += 1 + l + sovMeta(uint64(l))
	l = len(m.Table)
	n += 1 + l + sovMeta(uint64(l))
	if len(m.Columns) > 0 {
		for _, s := range m.Columns {
			l = len(s)
			n += 1 + l + sovMeta(uint64(l))
		}
	}
	l = len(m.Comment)
	n += 1 + l + sovMeta(uint64(l))
	n += 2
	n += 2
	n += 2
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PTableInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMeta(uint64(m.ID))
	l = len(m.Name)
	n += 1 + l + sovMeta(uint64(l))
	l = len(m.Charset)
	n += 1 + l + sovMeta(uint64(l))
	l = len(m.Collate)
	n += 1 + l + sovMeta(uint64(l))
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			l = e.Size()
			n += 1 + l + sovMeta(uint64(l))
		}
	}
	if len(m.Indices) > 0 {
		for _, e := range m.Indices {
			l = e.Size()
			n += 1 + l + sovMeta(uint64(l))
		}
	}
	n += 2
	n += 2
	l = len(m.Comment)
	n += 1 + l + sovMeta(uint64(l))
	n += 1 + sovMeta(uint64(m.AutoIncID))
	n += 1 + sovMeta(uint64(m.AutoIdCache))
	n += 1 + sovMeta(uint64(m.AutoRandID))
	n += 1 + sovMeta(uint64(m.MaxColumnID))
	n += 1 + sovMeta(uint64(m.MaxIndexID))
	n += 1 + sovMeta(uint64(m.MaxConstraintID))
	n += 2 + sovMeta(uint64(m.UpdateTS))
	n += 2 + sovMeta(uint64(m.OldSchemaID))
	n += 2 + sovMeta(uint64(m.ShardRowIDBits))
	n += 2 + sovMeta(uint64(m.MaxShardRowIDBits))
	n += 2 + sovMeta(uint64(m.AutoRandomBits))
	n += 2 + sovMeta(uint64(m.PreSplitRegions))
	l = len(m.Compression)
	n += 2 + l + sovMeta(uint64(l))
	n += 2 + sovMeta(uint64(m.Version))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovMeta(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMeta(x uint64) (n int) {
	return sovMeta(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *PColumnInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PColumnInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PColumnInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginDefaultValue", wireType)
			}
			m.OriginDefaultValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OriginDefaultValue |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginDefaultValueBit", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginDefaultValueBit = append(m.OriginDefaultValueBit[:0], dAtA[iNdEx:postIndex]...)
			if m.OriginDefaultValueBit == nil {
				m.OriginDefaultValueBit = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultValue", wireType)
			}
			m.DefaultValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultValue |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultValueBit", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultValueBit = append(m.DefaultValueBit[:0], dAtA[iNdEx:postIndex]...)
			if m.DefaultValueBit == nil {
				m.DefaultValueBit = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultIsExpr", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DefaultIsExpr = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeneratedExprString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GeneratedExprString = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeneratedStored", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GeneratedStored = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dependences", wireType)
			}
			m.Dependences = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dependences |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hidden", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Hidden = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PIndexInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PIndexInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PIndexInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Table = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unique", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Unique = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Primary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Primary = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Invisible", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Invisible = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PTableInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PTableInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PTableInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Charset", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Charset = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Collate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, &PColumnInfo{})
			if err := m.Columns[len(m.Columns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Indices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Indices = append(m.Indices, &PIndexInfo{})
			if err := m.Indices[len(m.Indices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PKIsHandle", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PKIsHandle = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCommonHandle", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsCommonHandle = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoIncID", wireType)
			}
			m.AutoIncID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoIncID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoIdCache", wireType)
			}
			m.AutoIdCache = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoIdCache |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoRandID", wireType)
			}
			m.AutoRandID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoRandID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxColumnID", wireType)
			}
			m.MaxColumnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxColumnID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxIndexID", wireType)
			}
			m.MaxIndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxIndexID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxConstraintID", wireType)
			}
			m.MaxConstraintID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxConstraintID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateTS", wireType)
			}
			m.UpdateTS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateTS |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldSchemaID", wireType)
			}
			m.OldSchemaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OldSchemaID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardRowIDBits", wireType)
			}
			m.ShardRowIDBits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardRowIDBits |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxShardRowIDBits", wireType)
			}
			m.MaxShardRowIDBits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxShardRowIDBits |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoRandomBits", wireType)
			}
			m.AutoRandomBits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoRandomBits |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreSplitRegions", wireType)
			}
			m.PreSplitRegions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PreSplitRegions |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Compression", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Compression = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMeta(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMeta
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMeta
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMeta
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMeta        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMeta          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMeta = fmt.Errorf("proto: unexpected end of group")
)
